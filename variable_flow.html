
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Variable Flow Visualization</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            select { margin-bottom: 20px; }
            .flow-item { margin-bottom: 20px; border: 1px solid #ccc; padding: 10px; }
            .filename { font-weight: bold; }
            .function-name { font-style: italic; color: #666; }
            .line-number { color: #888; margin-right: 10px; }
            .code { font-family: monospace; background-color: #f0f0f0; padding: 2px 4px; }
            .highlight { background-color: yellow; }
            .action { color: #007bff; }
        </style>
    </head>
    <body>
        <h1>Variable Flow Visualization</h1>
        <select id="variableSelect">
            <option value="">Select a variable</option>
            <option value="canvas">canvas</option>
<option value="actions">actions</option>
<option value="molecules">molecules</option>
<option value="smiles">smiles</option>
<option value="id">id</option>
<option value="steps">steps</option>
<option value="currentStep">currentStep</option>
<option value="stateHistory">stateHistory</option>
<option value="nextButton">nextButton</option>
<option value="previousButton">previousButton</option>
<option value="previousState">previousState</option>
<option value="moleculeData">moleculeData</option>
<option value="existingMolecule">existingMolecule</option>
<option value="position">position</option>
<option value="transitionInfo">transitionInfo</option>
<option value="ctx">ctx</option>
<option value="dx">dx</option>
<option value="dy">dy</option>
<option value="length">length</option>
<option value="offsetX">offsetX</option>
<option value="offsetY">offsetY</option>
<option value="currentOrder">currentOrder</option>
<option value="angle">angle</option>
<option value="drawLine">drawLine</option>
<option value="electronRadius">electronRadius</option>
<option value="electronCenterX">electronCenterX</option>
<option value="electronCenterY">electronCenterY</option>
<option value="perpendicularAngle">perpendicularAngle</option>
<option value="offset">offset</option>
<option value="electron1X">electron1X</option>
<option value="electron1Y">electron1Y</option>
<option value="electron2X">electron2X</option>
<option value="electron2Y">electron2Y</option>
<option value="currentCharge">currentCharge</option>
<option value="chargeText">chargeText</option>
<option value="lonePairs">lonePairs</option>
<option value="singleElectrons">singleElectrons</option>
<option value="lonePairRadius">lonePairRadius</option>
<option value="i">i</option>
<option value="angle1">angle1</option>
<option value="angle2">angle2</option>
<option value="x1">x1</option>
<option value="y1">y1</option>
<option value="x2">x2</option>
<option value="y2">y2</option>
<option value="x">x</option>
<option value="y">y</option>
<option value="coords2D">coords2D</option>
<option value="start">start</option>
<option value="end">end</option>
<option value="atomSymbol">atomSymbol</option>
<option value="centerX">centerX</option>
<option value="centerY">centerY</option>
<option value="size">size</option>
<option value="coords">coords</option>
<option value="minX">minX</option>
<option value="width">width</option>
<option value="height">height</option>
<option value="molecule">molecule</option>
<option value="atomCount">atomCount</option>
<option value="donorAtom">donorAtom</option>
<option value="receiverAtom">receiverAtom</option>
<option value="donorCharge">donorCharge</option>
<option value="donorLonePairs">donorLonePairs</option>
<option value="currentBondOrder">currentBondOrder</option>
<option value="charge1">charge1</option>
<option value="charge2">charge2</option>
<option value="bondKey">bondKey</option>
<option value="initialOrder">initialOrder</option>
<option value="targetOrder">targetOrder</option>
<option value="animate">animate</option>
<option value="moleculeInfo">moleculeInfo</option>
<option value="bondManipulator">bondManipulator</option>
<option value="hydrogensToRemove">hydrogensToRemove</option>
<option value="connectedAtoms">connectedAtoms</option>
<option value="j">j</option>
<option value="neighborIndex">neighborIndex</option>
<option value="coordinates3D">coordinates3D</option>
<option value="z">z</option>
<option value="bondCount">bondCount</option>
<option value="bondTypes">bondTypes</option>
<option value="atom1">atom1</option>
<option value="atom2">atom2</option>
<option value="bondOrder">bondOrder</option>
<option value="bondType">bondType</option>
<option value="formalCharges">formalCharges</option>
<option value="charge">charge</option>
<option value="bondIndex">bondIndex</option>
<option value="bondAtom1">bondAtom1</option>
<option value="bondAtom2">bondAtom2</option>
<option value="formalCharge">formalCharge</option>
<option value="bondOrders">bondOrders</option>
<option value="implicitHydrogens">implicitHydrogens</option>
<option value="explicitHydrogens">explicitHydrogens</option>
<option value="connectedAtom">connectedAtom</option>
<option value="valence">valence</option>
<option value="totalBondOrder">totalBondOrder</option>
<option value="bondingElectrons">bondingElectrons</option>
<option value="nonBondingElectrons">nonBondingElectrons</option>
<option value="tolerance">tolerance</option>
<option value="closestAtom">closestAtom</option>
<option value="minDistance">minDistance</option>
<option value="distance">distance</option>
        </select>
        <div id="flowContainer"></div>

        <script>
        const variables = {"canvas": [["chem.html", "declaration"], ["chem.html", "usage"], ["moleculeRenderer.js", "usage"]], "actions": [["chem.html", "declaration"], ["chem.html", "usage"]], "molecules": [["chem.html", "declaration"], ["chem.html", "usage"], ["moleculeRenderer.js", "usage"], ["action.js", "usage"]], "smiles": [["chem.html", "declaration"], ["chem.html", "usage"], ["moleculeRenderer.js", "usage"], ["action.js", "usage"], ["moleculeInfo.js", "usage"]], "id": [["chem.html", "declaration"], ["chem.html", "usage"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["action.js", "declaration"], ["action.js", "declaration"], ["action.js", "declaration"], ["action.js", "usage"]], "steps": [["chem.html", "declaration"], ["chem.html", "usage"]], "currentStep": [["chem.html", "declaration"], ["chem.html", "usage"]], "stateHistory": [["chem.html", "declaration"], ["chem.html", "usage"]], "nextButton": [["chem.html", "declaration"], ["chem.html", "usage"]], "previousButton": [["chem.html", "declaration"], ["chem.html", "usage"]], "previousState": [["chem.html", "declaration"], ["chem.html", "usage"]], "moleculeData": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "existingMolecule": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "position": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "transitionInfo": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "ctx": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "dx": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "dy": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "length": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["action.js", "usage"]], "offsetX": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "offsetY": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "currentOrder": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "angle": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "drawLine": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "electronRadius": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "electronCenterX": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "electronCenterY": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "perpendicularAngle": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "offset": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "electron1X": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "electron1Y": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "electron2X": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "electron2Y": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "currentCharge": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "chargeText": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "lonePairs": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "singleElectrons": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "lonePairRadius": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "i": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"], ["action.js", "declaration"], ["action.js", "usage"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "angle1": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "angle2": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "x1": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "y1": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "x2": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "y2": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "x": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "y": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "coords2D": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "start": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "end": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "atomSymbol": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "centerX": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "centerY": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "size": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "coords": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "minX": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "width": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "height": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"]], "molecule": [["moleculeRenderer.js", "declaration"], ["moleculeRenderer.js", "usage"], ["BondManipulator.js", "declaration"], ["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"], ["action.js", "declaration"], ["action.js", "declaration"], ["action.js", "usage"], ["moleculeInfo.js", "usage"]], "atomCount": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "donorAtom": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "receiverAtom": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "donorCharge": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "donorLonePairs": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "currentBondOrder": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "charge1": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "charge2": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "bondKey": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "initialOrder": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "targetOrder": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "animate": [["BondManipulator.js", "declaration"], ["BondManipulator.js", "usage"]], "moleculeInfo": [["action.js", "declaration"], ["action.js", "declaration"], ["action.js", "usage"]], "bondManipulator": [["action.js", "declaration"], ["action.js", "usage"]], "hydrogensToRemove": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "connectedAtoms": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "j": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "neighborIndex": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "coordinates3D": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "z": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "bondCount": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "bondTypes": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "atom1": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "atom2": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "bondOrder": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "bondType": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "formalCharges": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "charge": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "bondIndex": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "bondAtom1": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "bondAtom2": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "formalCharge": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "bondOrders": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "implicitHydrogens": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "explicitHydrogens": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "connectedAtom": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "valence": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "totalBondOrder": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "bondingElectrons": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "nonBondingElectrons": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "tolerance": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "closestAtom": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "minDistance": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]], "distance": [["moleculeInfo.js", "declaration"], ["moleculeInfo.js", "usage"]]};
        const fileContents = {"chem.html": "&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Molecule Visualization&lt;/title&gt;\n    &lt;style&gt;\n        body {\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n            height: 100vh;\n            margin: 0;\n            background-color: #f0f0f0;\n        }\n        #moleculeCanvas {\n            border: 1px solid #ccc;\n            background-color: #ffffff;\n            width: 100%;\n            height: 600px;\n        }\n        .button-container {\n            margin-top: 20px;\n        }\n        button {\n            margin: 0 10px;\n            padding: 10px 20px;\n            font-size: 16px;\n            cursor: pointer;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;canvas id=&quot;moleculeCanvas&quot;&gt;&lt;/canvas&gt;\n    &lt;div class=&quot;button-container&quot;&gt;\n        &lt;button id=&quot;previousButton&quot; disabled&gt;Previous&lt;/button&gt;\n        &lt;button id=&quot;nextButton&quot;&gt;Next&lt;/button&gt;\n    &lt;/div&gt;\n\n    &lt;!-- Include OCL.js from CDN --&gt;\n    &lt;script src=&quot;https://unpkg.com/openchemlib@latest/dist/openchemlib-full.js&quot;&gt;&lt;/script&gt;\n\n    &lt;!-- Include local JavaScript files --&gt;\n    &lt;script src=&quot;moleculeInfo.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;moleculeRenderer.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;bondManipulator.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;action.js&quot;&gt;&lt;/script&gt;\n\n    &lt;script&gt;\n        document.addEventListener(&#x27;DOMContentLoaded&#x27;, async () =&gt; {\n            const canvas = document.getElementById(&#x27;moleculeCanvas&#x27;);\n            canvas.width = canvas.offsetWidth;\n            canvas.height = canvas.offsetHeight;\n            const actions = new Actions(&#x27;moleculeCanvas&#x27;);\n            actions.renderer.setScaleFactor(60);\n\n            const molecules = [\n                &#x27;c1ccc(cc1)[N+](=O)[O-]&#x27;,  // Nitrobenzene\n                &#x27;CCO&#x27;,  // Ethanol\n            ];\n\n            for (const smiles of molecules) {\n                console.log(`Adding molecule: ${smiles}`);\n                const id = await actions.addMolecule(smiles, true);\n                console.log(`Added molecule with id: ${id}`);\n            }\n\n            const steps = [\n                () =&gt; actions.B2A(0, &quot;6-7&quot;),\n                () =&gt; actions.B2A(1, &quot;2-8&quot;),\n                () =&gt; actions.B2B(0, &quot;2-3-6&quot;),\n                // Add more steps as needed\n            ];\n\n            let currentStep = 0;\n            const stateHistory = [actions.renderer.getMolecules().map(m =&gt; m.moleculeInfo.getMolecule().toSmiles())];\n\n            const nextButton = document.getElementById(&#x27;nextButton&#x27;);\n            const previousButton = document.getElementById(&#x27;previousButton&#x27;);\n\n            nextButton.addEventListener(&#x27;click&#x27;, async () =&gt; {\n                if (currentStep &lt; steps.length) {\n                    steps[currentStep]();\n                    currentStep++;\n                    stateHistory.push(actions.renderer.getMolecules().map(m =&gt; m.moleculeInfo.getMolecule().toSmiles()));\n                    updateButtonStates();\n                }\n            });\n\n            previousButton.addEventListener(&#x27;click&#x27;, async () =&gt; {\n                if (currentStep &gt; 0) {\n                    currentStep--;\n                    stateHistory.pop(); // Remove the current state\n                    const previousState = stateHistory[stateHistory.length - 1];\n                    await actions.resetMolecules(previousState);\n                    updateButtonStates();\n                }\n            });\n\n            function updateButtonStates() {\n                previousButton.disabled = currentStep === 0;\n                nextButton.disabled = currentStep === steps.length;\n            }\n\n            updateButtonStates(); // Initial button state update\n\n            function animate() {\n                actions.renderer.renderMolecules();\n                requestAnimationFrame(animate);\n            }\n            animate(); // Start the animation loop\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n", "moleculeRenderer.js": "/**\n The moleculeRenderer.js file is responsible for rendering a visual representation of a molecule on an HTML canvas element. Here&#x27;s a breakdown of its key roles and functionalities:\n1. Initialization:\nThe MoleculeRenderer class is initialized with a canvas ID, which it uses to get the canvas element and its drawing context.\nIt sets up default properties such as scale factor, current SMILES string, and options for displaying implicit hydrogens and atom numbers.\n2. Rendering Molecules:\nThe renderMolecule method takes a SMILES string and options for displaying implicit hydrogens and atom numbers. It retrieves molecule data using the MoleculeInfo class and then draws the molecule on the canvas.\nIt handles clearing the canvas before drawing and manages the rendering of atoms and bonds.\n3. Drawing Atoms and Bonds:\nThe drawAtom method is responsible for drawing individual atoms, including their symbols, optional atom numbers, charges, and lone pairs.\nThe drawBond method draws bonds between atoms, considering bond types (single, double, triple) and any ongoing bond transitions.\n4. Bond Transitions:\nThe renderer can visualize bond transitions, such as changing bond orders and electron movements, using methods like drawTransitioningBond and drawMovingElectrons.\n5. Utility Methods:\nMethods like clear, setScaleFactor, and project3Dto2D help manage the rendering process, including clearing the canvas, setting the scale for rendering, and projecting 3D coordinates to 2D for display.\n6. Integration with Bond Manipulator:\nThe renderer can integrate with a BondManipulator instance to dynamically update the visualization based on bond manipulations, such as electron movements and bond order changes.\nOverall, moleculeRenderer.js is a crucial component for visualizing molecular structures, providing a graphical interface for users to interact with and understand molecular data.\n */\nclass MoleculeRenderer {\n  constructor(canvasId) {\n    // Initialize canvas and context for drawing\n    this.canvas = document.getElementById(canvasId);\n    this.ctx = this.canvas.getContext(&#x27;2d&#x27;);\n    this.molecules = [];\n    this.scaleFactor = 50;\n    this.padding = 20; // Padding between molecules\n    this.startX = 50; // Starting X position\n    this.startY = 50; // Starting Y position\n    this.currentX = this.startX;\n    this.currentY = this.startY;\n    this.maxHeight = 0; // Max height of molecules in the current row\n    this.moleculeInfo = new MoleculeInfo(); // Helper class for molecule data\n    this.showImplicitHydrogens = true; // Default value\n    this.showAtomNumbers = false; // Default value\n\n    // Define color maps for atoms and bonds\n    this.atomColors = {\n      H: &#x27;gray&#x27;,\n      C: &#x27;black&#x27;,\n      O: &#x27;red&#x27;,\n      N: &#x27;blue&#x27;,\n      // Add more atom types as needed\n    };\n\n    this.bondColors = {\n      single: &#x27;black&#x27;,\n      double: &#x27;red&#x27;,\n      triple: &#x27;green&#x27;,\n      other: &#x27;purple&#x27;,\n    };\n\n    this.isAnimating = false;\n    this.animationFrameId = null;\n    this.moleculeMap = new Map();\n  }\n\n  // Render a molecule based on SMILES string\n  async initialize(smiles, showImplicitHydrogens = true, showAtomNumbers = false) {\n    this.moleculeInfo = new MoleculeInfo();\n    await this.moleculeInfo.initializeMolecule(smiles, showImplicitHydrogens);\n    this.showAtomNumbers = showAtomNumbers;\n    this.renderMolecule();\n  }\n\n  renderMolecule(moleculeInfo) {\n    if (!moleculeInfo) {\n      console.error(&#x27;MoleculeInfo is not provided&#x27;);\n      return;\n    }\n  \n    const moleculeData = {\n      coordinates3D: moleculeInfo.getCoordinates3D(),\n      bondTypes: moleculeInfo.getBondTypes(),\n      formalCharges: moleculeInfo.getFormalCharges(),\n    };\n    // Get the existing position of the molecule\n    const existingMolecule = this.molecules.find(m =&gt; m.moleculeInfo === moleculeInfo);\n    let position = { x: 0, y: 0 };\n    \n    if (existingMolecule) {\n      position = existingMolecule.position;\n    }\n    this.clear();\n    this.drawMolecule(moleculeData, this.showAtomNumbers, position, moleculeInfo, this.bondManipulator);\n  }\n\n  // Clear the canvas\n  clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  // Set bond manipulator for dynamic bond manipulation\n  setBondManipulator(bondManipulator) {\n    this.bondManipulator = bondManipulator;\n    // Add this line to ensure the renderer has the latest moleculeInfo\n    this.moleculeInfo = bondManipulator.moleculeInfo;\n  }\n\n  // Draw a bond between two atoms\n  drawBond(start, end, bondType, atom1, atom2, bondManipulator) {\n    \n    const transitionInfo = bondManipulator &amp;&amp; bondManipulator.getBondTransitionProgress(atom1, atom2);\n    \n    if (transitionInfo) {      \n      console.log(`Drawing transitioning bond ${atom1}-${atom2}, progress: ${transitionInfo.progress}`);\n      this.drawTransitioningBond(start, end, transitionInfo);\n    } else {      \n      this.drawNormalBond(start, end, bondType);\n    }\n  }\n\n  // Draw a normal bond (single, double, triple)\n  drawNormalBond(start, end, bondType) {\n    const ctx = this.ctx;\n    ctx.strokeStyle = this.bondColors[bondType] || this.bondColors.single;\n    ctx.lineWidth = 1;\n    // Check if there&#x27;s a bond between the atoms\n    if (bondType === &#x27;none&#x27;) {\n      // If there&#x27;s no bond, don&#x27;t draw anything\n      return;\n    }\n\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const offsetX = (dy / length) * 3;\n    const offsetY = -(dx / length) * 3;\n\n    // Draw first line\n    ctx.beginPath();\n    ctx.moveTo(start.x, start.y);\n    ctx.lineTo(end.x, end.y);\n    ctx.stroke();\n\n    if (bondType === &#x27;double&#x27; || bondType === &#x27;triple&#x27;) {\n      // Draw second line\n      ctx.beginPath();\n      ctx.moveTo(start.x + offsetX, start.y + offsetY);\n      ctx.lineTo(end.x + offsetX, end.y + offsetY);\n      ctx.stroke();\n    }\n\n    if (bondType === &#x27;triple&#x27;) {\n      // Draw third line\n      ctx.beginPath();\n      ctx.moveTo(start.x - offsetX, start.y - offsetY);\n      ctx.lineTo(end.x - offsetX, end.y - offsetY);\n      ctx.stroke();\n    }\n  }\n\n  // Draw a transitioning bond with electron movement\n  drawTransitioningBond(start, end, transitionInfo) {\n    const { progress, initialOrder, targetOrder, bondChange, electronMovement } = transitionInfo;\n    const currentOrder = initialOrder + (targetOrder - initialOrder) * progress;\n\n    // Draw the transitioning bond\n    this.drawInterpolateBond(start, end, currentOrder);\n\n    // Draw moving electrons\n    this.drawMovingElectrons(start, end, progress, electronMovement);\n  }\n\n  drawInterpolateBond(start, end, order) {\n    const ctx = this.ctx;\n    ctx.strokeStyle = &#x27;black&#x27;;\n    ctx.lineWidth = 1;\n\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n\n    const drawLine = (offset) =&gt; {\n      const offsetX = Math.sin(angle) * offset;\n      const offsetY = -Math.cos(angle) * offset;\n      ctx.beginPath();\n      ctx.moveTo(start.x + offsetX, start.y + offsetY);\n      ctx.lineTo(end.x + offsetX, end.y + offsetY);\n      ctx.stroke();\n    };\n\n    if (order &lt;= 1) {\n      drawLine(0);\n    } else if (order &lt;= 2) {\n      drawLine(-1);\n      drawLine(1);\n    } else {\n      drawLine(-2);\n      drawLine(0);\n      drawLine(2);\n    }\n  }\n\n  drawMovingElectrons(start, end, progress, electronMovement) {\n    const ctx = this.ctx;\n    ctx.fillStyle = &#x27;blue&#x27;;\n    const electronRadius = 2; // Slightly reduced size for two electrons\n\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const angle = Math.atan2(dy, dx);\n\n    let position;\n    if (electronMovement === &#x27;bond-to-atom&#x27;) {\n      position = length * progress;\n    } else if (electronMovement === &#x27;bond-to-bond&#x27;) {\n      position = length * 0.5 * progress;\n    }\n\n    const electronCenterX = start.x + Math.cos(angle) * position;\n    const electronCenterY = start.y + Math.sin(angle) * position;\n\n    // Calculate perpendicular offset for the two electrons\n    const perpendicularAngle = angle + Math.PI / 2;\n    const offset = 3; // Distance between the two electrons\n\n    // Draw first electron\n    const electron1X = electronCenterX + Math.cos(perpendicularAngle) * offset;\n    const electron1Y = electronCenterY + Math.sin(perpendicularAngle) * offset;\n    ctx.beginPath();\n    ctx.arc(electron1X, electron1Y, electronRadius, 0, 2 * Math.PI);\n    ctx.fill();\n\n    // Draw second electron\n    const electron2X = electronCenterX - Math.cos(perpendicularAngle) * offset;\n    const electron2Y = electronCenterY - Math.sin(perpendicularAngle) * offset;\n    ctx.beginPath();\n    ctx.arc(electron2X, electron2Y, electronRadius, 0, 2 * Math.PI);\n    ctx.fill();\n\n    console.log(`Drawing electron pair at (${electronCenterX}, ${electronCenterY}), progress: ${progress}`);\n  }\n\n  getBondTypeFromOrder(order) {\n    switch (order) {\n      case 1: return &#x27;single&#x27;;\n      case 2: return &#x27;double&#x27;;\n      case 3: return &#x27;triple&#x27;;\n      default: return &#x27;single&#x27;;\n    }\n  }\n\n  // Draw an atom with optional atom number, charge, and lone pairs\n  drawAtom(coord, atomSymbol, atomIndex, showAtomNumbers, formalCharge, moleculeInfo, bondManipulator) {\n    this.ctx.font = &#x27;bold 16px Arial&#x27;;\n    this.ctx.fillStyle = this.atomColors[atomSymbol] || &#x27;black&#x27;;\n    this.ctx.fillText(atomSymbol, coord.x - 8, coord.y + 8);\n\n    if (showAtomNumbers) {\n      this.ctx.fillStyle = &#x27;blue&#x27;;\n      this.ctx.fillText(atomIndex, coord.x + 10, coord.y + 8);\n    }\n\n    // Get the current charge from the bond manipulator\n    let currentCharge = bondManipulator ? bondManipulator.getCharge(atomIndex) : formalCharge;\n\n    // Draw the charge if it is not zero\n    if (currentCharge !== 0) {\n      this.ctx.fillStyle = &#x27;purple&#x27;; // Use purple for charges\n      this.ctx.font = &#x27;14px Arial&#x27;;\n      const chargeText = currentCharge &gt; 0 ? `+${currentCharge}` : `${currentCharge}`;\n      this.ctx.fillText(chargeText, coord.x + 3, coord.y - 10);\n    }\n\n    // Draw lone pairs using stored information\n    const lonePairs = moleculeInfo.getLonePairs(atomIndex);\n    this.drawLonePairs(coord, lonePairs);\n\n    // Draw single electrons\n    const singleElectrons = moleculeInfo.getSingleElectron(atomIndex);\n    this.drawSingleElectrons(coord, singleElectrons);\n  }\n\n  // Draw lone pairs around an atom\n  drawLonePairs(coord, numberOfLonePairs) {\n    const ctx = this.ctx;\n    const lonePairRadius = 2; // Radius of the lone pair dots\n    const offset = 10; // Distance from the atom center\n\n    ctx.fillStyle = &#x27;blue&#x27;; // Color for lone pairs\n\n    for (let i = 0; i &lt; numberOfLonePairs; i++) {\n      // Calculate positions for two electrons per lone pair\n      const angle1 = (Math.PI / 2) * i;\n      const angle2 = angle1 + Math.PI / 8; // Slightly offset the second electron\n\n      const x1 = coord.x + offset * Math.cos(angle1);\n      const y1 = coord.y + offset * Math.sin(angle1);\n\n      const x2 = coord.x + offset * Math.cos(angle2);\n      const y2 = coord.y + offset * Math.sin(angle2);\n\n      // Draw first electron\n      ctx.beginPath();\n      ctx.arc(x1, y1, lonePairRadius, 0, 2 * Math.PI);\n      ctx.fill();\n\n      // Draw second electron\n      ctx.beginPath();\n      ctx.arc(x2, y2, lonePairRadius, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }\n\n  // New method to draw single electrons\n  drawSingleElectrons(coord, numberOfSingleElectrons) {\n    const ctx = this.ctx;\n    const electronRadius = 3; // Slightly larger than lone pairs for visibility\n    const offset = 15; // Slightly further from the atom center than lone pairs\n\n    ctx.fillStyle = &#x27;red&#x27;; // Color for single electrons\n\n    for (let i = 0; i &lt; numberOfSingleElectrons; i++) {\n      const angle = (Math.PI / 6) * i;\n      const x = coord.x - offset * Math.cos(angle);\n      const y = coord.y + offset * Math.sin(angle);\n\n      ctx.beginPath();\n      ctx.arc(x, y, electronRadius, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }\n\n  // Draw the entire molecule\n  drawMolecule(moleculeData, showAtomNumbers, position = { x: 0, y: 0 }, moleculeInfo, bondManipulator) {\n    const { coordinates3D, bondTypes, formalCharges } = moleculeData;\n    \n    this.ctx.save();\n    this.ctx.translate(position.x, position.y);\n    \n    // Project 3D coordinates to 2D\n    const coords2D = this.project3Dto2D(coordinates3D);\n    \n    // Draw bonds first\n    bondTypes.forEach(bond =&gt; {\n      const start = { ...coords2D[bond.atom1], atomIndex: bond.atom1 };\n      const end = { ...coords2D[bond.atom2], atomIndex: bond.atom2 };\n      this.drawBond(start, end, bond.type, bond.atom1, bond.atom2, bondManipulator);\n    });\n    // Draw atoms on top of bonds\n    coords2D.forEach((coord, index) =&gt; {\n      const atomSymbol = moleculeInfo.getAtomSymbol(index);\n      this.drawAtom(coord, atomSymbol, index, showAtomNumbers, formalCharges[index], moleculeInfo, bondManipulator);\n    });\n    \n    this.ctx.restore();\n  }\n\n  // Project 3D coordinates to 2D for rendering\n  project3Dto2D(coords3D) {\n    const centerX = 10;\n    const centerY = this.canvas.height / 2;\n\n    return coords3D.map(coord =&gt; ({\n      x: coord.x * this.scaleFactor + centerX,\n      y: -coord.y * this.scaleFactor + centerY // Invert y-axis\n    }));\n  }\n\n  // Set the scale factor for rendering\n  setScaleFactor(scale) {\n    this.scaleFactor = scale;\n  }\n\n  // Get the current molecule object\n  getMolecule() {\n    return this.moleculeInfo.getMolecule();\n  }\n\n  addMolecule(moleculeInfo, bondManipulator, showAtomNumbers) {\n    const id = `molecule_${this.moleculeMap.size}`; // Generate a unique ID\n    const position = this.calculateNextPosition(moleculeInfo);\n    const size = this.calculateMoleculeSize(moleculeInfo);\n\n    this.moleculeMap.set(id, {\n      moleculeInfo,\n      bondManipulator,\n      showAtomNumbers,\n      position,\n      size\n    });\n\n    this.renderMolecules();\n    return id; // Return the unique ID instead of an index\n  }\n\n  calculateNextPosition(moleculeInfo) {\n    const size = this.calculateMoleculeSize(moleculeInfo);\n    \n    if (this.currentX + size.width &gt; this.canvas.width - this.padding) {\n      // Start a new row\n      this.currentX = this.startX;\n      this.currentY += this.maxHeight + this.padding;\n      this.maxHeight = 0;\n    }\n\n    const position = { x: this.currentX, y: this.currentY };\n\n    // Update for next molecule\n    this.currentX += size.width + this.padding;\n    this.maxHeight = Math.max(this.maxHeight, size.height);\n\n    return position;\n  }\n\n  calculateMoleculeSize(moleculeInfo) {\n    const coords = moleculeInfo.getCoordinates3D();\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    \n    coords.forEach(coord =&gt; {\n      minX = Math.min(minX, coord.x);\n      minY = Math.min(minY, coord.y);\n      maxX = Math.max(maxX, coord.x);\n      maxY = Math.max(maxY, coord.y);\n    });\n\n    const width = (maxX - minX) * this.scaleFactor + 40;  // Add some padding\n    const height = (maxY - minY) * this.scaleFactor + 40;\n\n    return { width, height };\n  }\n\n  renderMolecules() {\n    this.clear();\n    for (const [id, molecule] of this.moleculeMap) {\n      const { moleculeInfo, bondManipulator, showAtomNumbers, position } = molecule;\n      const moleculeData = {\n        coordinates3D: moleculeInfo.getCoordinates3D(),\n        bondTypes: moleculeInfo.getBondTypes(),\n        formalCharges: moleculeInfo.getFormalCharges(),\n      };\n      this.drawMolecule(moleculeData, showAtomNumbers, position, moleculeInfo, bondManipulator);\n    }\n  }\n\n  startAnimation() {\n    if (!this.isAnimating) {\n      this.isAnimating = true;\n      this.animate();\n    }\n  }\n\n  stopAnimation() {\n    this.isAnimating = false;\n    if (this.animationFrameId) {\n      cancelAnimationFrame(this.animationFrameId);\n      this.animationFrameId = null;\n    }\n  }\n\n  animate() {\n    if (this.isAnimating) {\n      this.renderMolecules();\n      this.animationFrameId = requestAnimationFrame(() =&gt; this.animate());\n    }\n  }\n\n  getMolecules() {\n    return Array.from(this.moleculeMap.values());\n  }\n\n  updateMolecule(id, newMoleculeInfo) {\n    if (this.moleculeMap.has(id)) {\n      const molecule = this.moleculeMap.get(id);\n      molecule.moleculeInfo = newMoleculeInfo;\n      molecule.bondManipulator = new BondManipulator(newMoleculeInfo, this);\n    }\n  }\n}", "BondManipulator.js": "/**\n The BondManipulator.js file is responsible for handling the manipulation of bonds within a molecule. It provides functionality to change bond orders and manage electron movements, which are crucial for simulating chemical reactions or visualizing changes in molecular structures. Here&#x27;s a breakdown of its key roles and functionalities:\nInitialization:\nThe BondManipulator class is initialized with a MoleculeInfo instance and a MoleculeRenderer instance. This allows it to access molecular data and update the visual representation of the molecule.\n2. Bond Manipulation:\nThe moveElectronPairFromBondToAtom method allows for the manipulation of a specific bond identified by a bond identifier (e.g., &#x27;1-2&#x27; for a bond between atoms 1 and 2). It supports different types of electron movements, such as &#x27;combined&#x27; and &#x27;split&#x27;.\nIt updates the charges on the atoms involved in the bond based on the type of electron movement.\n3. Animation of Bond Transitions:\nThe startBondTransition method initiates an animation to visually represent the transition of a bond from one state to another. This includes changing bond orders and moving electrons.\nThe animation is handled using requestAnimationFrame to smoothly update the bond&#x27;s visual state over time.\n4. Charge Management:\nThe updateCharges method adjusts the formal charges of the atoms involved in a bond based on the electron movement type. This is important for accurately representing the electronic state of the molecule.\n5. Utility Methods:\nfindBondIndex helps locate the index of a bond between two atoms within the molecule.\ngetBondTransitionProgress retrieves the current progress of a bond transition, which is used by the renderer to update the visual representation.\ngetCharge returns the current charge of a specific atom, which can be used to display charge information in the visualization.\nOverall, BondManipulator.js is a crucial component for dynamically altering molecular structures and visualizing these changes, providing an interactive way to explore chemical reactions and molecular behavior.\n */\nclass BondManipulator {\n  constructor(moleculeInfo, renderer) {\n    this.moleculeInfo = moleculeInfo;\n    this.renderer = renderer;\n    this.bondTransitions = new Map();\n    this.charges = new Map();\n\n    // Initialize charges for all atoms\n    const atomCount = this.moleculeInfo.getAtomCount();\n    for (let i = 0; i &lt; atomCount; i++) {\n      this.charges.set(i, this.moleculeInfo.getFormalCharge(i));\n    }\n  }\n\n  // Updated method to move electrons from the first atom in the bond to the bond\n  moveElectronPairFromAtomToBond(bondIdentifier) {\n    const [atom1, atom2] = bondIdentifier.split(&#x27;-&#x27;).map(Number);\n    const donorAtom = atom1; // The first atom in the identifier is the donor\n    const receiverAtom = atom2; // The second atom in the identifier is the receiver\n    console.log(`Attempting to move electron pair from atom ${donorAtom} to bond ${bondIdentifier}`);\n    \n    const molecule = this.moleculeInfo.getMolecule();\n    if (!molecule) {\n      console.error(&#x27;Molecule is not initialized.&#x27;);\n      return;\n    }\n\n    // Check if donor atom has a negative charge or lone pair\n    const donorCharge = this.getCharge(donorAtom);\n    const donorLonePairs = this.moleculeInfo.getLonePairs(donorAtom);\n\n    if (donorCharge &lt; 0 || donorLonePairs &gt; 0) {\n      // Start the bond transition animation\n      console.log(&quot;i am in&quot;);\n      this.startBondTransition(donorAtom, receiverAtom, &#x27;increase&#x27;, donorAtom);\n\n      // Update the bond order\n      const currentOrder = this.moleculeInfo.getBondOrder(atom1, atom2);\n      if (currentOrder &lt; 3) {\n        this.moleculeInfo.setBondOrder(atom1, atom2, currentOrder + 1);\n        console.log(&quot;current order: &quot; + this.moleculeInfo.getBondOrder(atom1, atom2));\n        // Update charges using the updateCharges method\n        this.updateCharges(donorAtom, receiverAtom, &#x27;A2B&#x27;);\n      }\n    } else {\n      console.log(`Cannot move electron pair: donor atom ${donorAtom} has no negative charge or lone pairs.`);\n    }\n  }\n  moveElectronPairFromBondToAtom(bondIdentifier) {\n    console.log(`Manipulating bond: ${bondIdentifier}`);\n    const [atom1, atom2] = bondIdentifier.split(&#x27;-&#x27;).map(Number);\n    this.startBondTransition(atom1, atom2, &#x27;decrease&#x27;, &#x27;bond-to-atom&#x27;);\n    \n    // Update charges: atom2 (receiving atom) gets -1 charge, atom1 (donating atom) gets +1 charge\n    this.updateCharge(atom2, -1);  // Receiving atom gets -1 charge\n    this.updateCharge(atom1, +1);  // Donating atom gets +1 charge\n  }\n  // Always move electrons towards the second atom in the identifier\n  moveElectronsBetweenBonds(bondPath) {\n    console.log(`Moving electrons along bond path: ${bondPath}`);\n    const [atom1, atom2, atom3] = bondPath.split(&#x27;-&#x27;).map(Number);\n    this.startBondTransition(atom1, atom2, &#x27;decrease&#x27;, &#x27;bond-to-bond&#x27;);\n    this.startBondTransition(atom2, atom3, &#x27;increase&#x27;, &#x27;bond-to-bond&#x27;);\n    \n    // Update charges: atom1 (start) gets +1 charge, atom3 (end) gets -1 charge, atom2 (middle) is unaffected\n    this.updateCharge(atom1, +1);  // First atom in the path gets +1 charge\n    this.updateCharge(atom3, -1);  // Last atom in the path gets -1 charge\n    // atom2 (middle atom) charge remains unchanged\n  }  \n  B2ASingle(bondIdentifier) {\n    console.log(`Splitting bond: ${bondIdentifier}`);\n    const [atom1, atom2] = bondIdentifier.split(&#x27;-&#x27;).map(Number);\n    const molecule = this.moleculeInfo.getMolecule();\n    if (!molecule) {\n      console.error(&#x27;Molecule is not initialized.&#x27;);\n      return;\n    }\n    \n    const currentBondOrder = this.moleculeInfo.getBondOrder(atom1, atom2);\n    if (currentBondOrder &gt; 0) {\n      \n      // Add single electrons to both atoms\n      this.moleculeInfo.setSingleElectron(atom1, this.moleculeInfo.getSingleElectron(atom1) + 1);\n      this.moleculeInfo.setSingleElectron(atom2, this.moleculeInfo.getSingleElectron(atom2) + 1);\n      console.log(`Added single electrons to atoms ${atom1} and ${atom2}`);\n\n      // Start the bond transition animation\n      this.startBondTransition(atom1, atom2, &#x27;decrease&#x27;);\n    } else {\n      console.log(&quot;Bond order is already 0, cannot split further.&quot;);\n    }\n  }\n    // Helper method to update charges\n  updateCharges(atom1, atom2, movementType) {\n      const charge1 = this.getCharge(atom1);\n      const charge2 = this.getCharge(atom2);\n      if (movementType === &#x27;A2B&#x27;) {\n        this.charges.set(atom1, charge1 + 1);\n        this.charges.set(atom2, charge2 - 1);\n          // Check if the donor atom has available electrons to move\n        let lonePairs = this.moleculeInfo.getLonePairs(atom1);\n        if (this.getCharge(atom1) &lt; 0 || lonePairs &gt; 0) {\n          // Decrease lone pairs if available, otherwise the charge update is sufficient\n          if (lonePairs &gt; 0) {\n            this.moleculeInfo.lonePairs[atom1] = lonePairs - 1;\n          }\n        } else {\n          console.warn(&#x27;No electron pair available to move from atom:&#x27;, atom1);\n          return;\n        }\n      } else if (movementType === &quot;combined&quot;) { //if both electron move from bond to atom\n        this.charges.set(atom1, charge1 - 1);\n        this.charges.set(atom2, charge2 + 1);\n      } else if (movementType === &#x27;B2B&#x27;) {\n        \n        this.charges.set(atom1, charge1 -1 );\n        this.charges.set(atom2, charge2 + 1);\n      }\n      \n      \n    }\n  \n    // Helper method to get the current charge of an atom\n  getCharge(atom) {\n      return this.charges.get(atom) ?? 0; // Return 0 if no charge is set\n    }\n    \n  // New method to move electrons from one bond to another\n\n\n\n\n  startBondTransition(atom1, atom2, bondChange, electronMovement) {\n    const bondKey = `${Math.min(atom1, atom2)}-${Math.max(atom1, atom2)}`;\n    const initialOrder = this.moleculeInfo.getBondOrder(atom1, atom2);\n    const targetOrder = bondChange === &#x27;increase&#x27; ? Math.min(3, initialOrder + 1) : Math.max(0, initialOrder - 1);\n\n    this.bondTransitions.set(bondKey, {\n      progress: 0,\n      initialOrder,\n      targetOrder,\n      bondChange,\n      electronMovement,\n      atom1,\n      atom2\n    });\n\n    const animate = () =&gt; {\n      const transitionInfo = this.bondTransitions.get(bondKey);\n      if (!transitionInfo) return;\n\n      transitionInfo.progress = Math.min(transitionInfo.progress + 0.005, 1);\n      console.log(`Bond ${bondKey} transition progress: ${transitionInfo.progress}`);\n      this.bondTransitions.set(bondKey, transitionInfo);\n\n      if (transitionInfo.progress &lt; 1) {\n        requestAnimationFrame(animate);\n      } else {\n        this.moleculeInfo.setBondOrder(atom1, atom2, transitionInfo.targetOrder);\n        this.bondTransitions.delete(bondKey);\n      }\n\n      this.renderer.renderMolecules();\n    };\n\n    animate();\n  }\n\n  getBondTransitionProgress(atom1, atom2) {\n    return this.bondTransitions.get(`${Math.min(atom1, atom2)}-${Math.max(atom1, atom2)}`);\n  }\n\n  updateCharge(atomIndex, change) {\n    const currentCharge = this.charges.get(atomIndex);\n    this.charges.set(atomIndex, currentCharge + change);\n    console.log(`Updated charge for atom ${atomIndex}: ${this.charges.get(atomIndex)}`);\n  }\n\n  getCharge(atomIndex) {\n    return this.charges.get(atomIndex);\n  }\n}\n\n\n\n\n\n\n", "action.js": "// Import necessary classes\n// Assuming these classes are available globally or through a module system\n// import { BondManipulator } from &#x27;./BondManipulator&#x27;;\n// import { MoleculeInfo } from &#x27;./moleculeInfo&#x27;;\n// import { MoleculeRenderer } from &#x27;./moleculeRenderer&#x27;;\n\nclass Actions {\n    constructor(canvasId) {\n        this.canvasId = canvasId;\n        this.renderer = new MoleculeRenderer(canvasId);\n        this.moleculeIds = []; // Add this line to store molecule IDs\n    }\n\n    async addMolecule(smiles, showNumbers = false) {\n        try {\n            const moleculeInfo = new MoleculeInfo();\n            await moleculeInfo.initializeMolecule(smiles, true);\n            const bondManipulator = new BondManipulator(moleculeInfo, this.renderer);\n            const id = this.renderer.addMolecule(moleculeInfo, bondManipulator, showNumbers);\n            this.moleculeIds.push(id); // Store the ID\n            this.renderer.renderMolecules(); // Add this line to ensure rendering after adding\n            return id;\n        } catch (error) {\n            console.error(&#x27;Error adding molecule:&#x27;, error);\n            throw error;\n        }\n    }\n\n    async resetMolecules(smilesArray) {\n        for (let i = 0; i &lt; smilesArray.length; i++) {\n            const moleculeInfo = new MoleculeInfo();\n            await moleculeInfo.initializeMolecule(smilesArray[i], true);\n            const id = this.moleculeIds[i];\n            this.renderer.updateMolecule(id, moleculeInfo);\n        }\n        this.renderer.renderMolecules();\n    }\n\n    // Method to move an electron pair from a bond to the second atom\n    B2A(moleculeIndex, bondIdentifier) {\n        const id = this.moleculeIds[moleculeIndex];\n        const molecule = this.renderer.moleculeMap.get(id);\n        if (!molecule || !molecule.bondManipulator) {\n            console.error(`No bond manipulator found for molecule at index ${moleculeIndex}`);\n            return;\n        }\n        console.log(`Triggering B2A for molecule ${id}, bond ${bondIdentifier}`);\n        molecule.bondManipulator.moveElectronPairFromBondToAtom(bondIdentifier);\n        this.renderer.startAnimation();\n    }\n\n\n    \n    A2B(bondIdentifier) {\n        const [atom1, atom2] = bondIdentifier.split(&#x27;-&#x27;).map(Number);\n        this.bondManipulator.moveElectronPairFromBondToAtom(bondIdentifier);\n        // Add this line:\n        //this.bondManipulator.startBondTransition(atom1, atom2, &#x27;increase&#x27;, bondIdentifier);\n        \n    }\n\n    // Updated B2B method to use molecule index\n    B2B(moleculeIndex, bondPath) {\n        if (moleculeIndex &lt; 0 || moleculeIndex &gt;= this.renderer.molecules.length) {\n            console.error(`Invalid molecule index: ${moleculeIndex}`);\n            return;\n        }\n\n        const molecule = this.renderer.molecules[moleculeIndex];\n        if (!molecule || !molecule.bondManipulator) {\n            console.error(`No bond manipulator found for molecule at index ${moleculeIndex}`);\n            return;\n        }\n        console.log(`Triggering B2B for molecule ${moleculeIndex}, bond path ${bondPath}`);\n        molecule.bondManipulator.moveElectronsBetweenBonds(bondPath);\n        this.renderer.startAnimation(); // Ensure animation is running\n    }\n    //method to create free radicals\n    B2ASingle(bondIdentifier) {\n        this.bondManipulator.B2ASingle(bondIdentifier);\n    }\n}\n\n\n\n", "moleculeInfo.js": "/*\n The MoleculeInfo class in moleculeInfo.js is designed to store and manage information about a molecule. Here&#x27;s a breakdown of the information it handles:\nMolecule Object:\nThe class stores a molecule object initialized from a SMILES string using the OpenChemLib library. This object is used to access various properties and methods related to the molecule.\nLone Pairs:\nThe class maintains a dictionary (lonePairs) to store the number of lone pairs for each atom in the molecule. It calculates these based on the atom type and formal charge.\nDefault Lone Pairs:\nA dictionary (defaultLonePairs) is defined to store the typical number of lone pairs for common atom types like Oxygen and Nitrogen.\n4. Coordinates:\nThe class retrieves 3D coordinates for each atom in the molecule, which can be used for rendering or further analysis.\nBond Types:\nIt extracts information about the bonds in the molecule, including the atoms involved and the bond order (single, double, triple, etc.).\nFormal Charges:\nThe class stores the formal charge for each atom, which is used to adjust lone pairs and can be displayed in visualizations.\nMethods:\ncalculateLonePairs(): Calculates and stores the number of lone pairs for each atom.\ngetMoleculeInfo(smiles, showImplicitHydrogens): Initializes the molecule from a SMILES string and retrieves various properties like coordinates, bond types, and formal charges.\ngetMolecule(): Returns the current molecule object.\ngetAtomSymbol(index): Returns the symbol of an atom by its index.\ngetLonePairs(atomIndex): Returns the number of lone pairs for a specific atom.\nThis class is essential for managing and providing detailed information about the molecule, which can be used by other components like the renderer or bond manipulator.\n */\nclass MoleculeInfo {\n  constructor() {\n    this.molecule = null; // Initialize molecule as null\n    this.lonePairs = {}; // Dictionary to store lone pair information\n    this.valenceElectrons = {\n      &#x27;H&#x27;: 1, &#x27;C&#x27;: 4, &#x27;N&#x27;: 5, &#x27;O&#x27;: 6, &#x27;F&#x27;: 7, &#x27;Cl&#x27;: 7, &#x27;Br&#x27;: 7, &#x27;I&#x27;: 7\n      // Add more elements as needed\n    };\n    this.singleElectrons = {}; // New property to track single electrons\n  }\n\n  // Get the symbol of an atom by its index\n  getAtomSymbol(index) {\n    if (!this.molecule) {\n      throw new Error(&#x27;Molecule is not initialized.&#x27;);\n    }\n    return this.molecule.getAtomLabel(index);\n  }\n\n  // Retrieve molecule information from a SMILES string\n  async initializeMolecule(smiles, showImplicitHydrogens = true) {\n    if (!smiles || typeof smiles !== &#x27;string&#x27;) {\n      throw new Error(&#x27;Invalid SMILES string.&#x27;);\n    }\n\n    this.molecule = OCL.Molecule.fromSmiles(smiles);\n    if (!this.molecule) {\n      throw new Error(&#x27;Failed to initialize molecule.&#x27;);\n    }\n\n    this.molecule.addImplicitHydrogens();\n    if (!showImplicitHydrogens) {\n      this.removeImplicitHydrogens();\n    }\n    this.molecule.ensureHelperArrays(OCL.Molecule.cHelperRings);\n    this.molecule.setFragment(false);\n    this.initializeLonePairs();  // Add this line\n  }\n\n  removeImplicitHydrogens() {\n    const atomCount = this.molecule.getAllAtoms();\n    const hydrogensToRemove = new Set();\n\n    for (let i = 0; i &lt; atomCount; i++) {\n      if (this.molecule.getAtomLabel(i) === &#x27;C&#x27;) {\n        const connectedAtoms = this.molecule.getAllConnAtoms(i);\n        for (let j = 0; j &lt; connectedAtoms; j++) {\n          const neighborIndex = this.molecule.getConnAtom(i, j);\n          if (this.molecule.getAtomLabel(neighborIndex) === &#x27;H&#x27;) {\n            hydrogensToRemove.add(neighborIndex);\n          }\n        }\n      }\n    }\n\n    // Remove hydrogens after collecting all indices to avoid index shifting issues\n    Array.from(hydrogensToRemove).sort((a, b) =&gt; b - a).forEach(hIndex =&gt; {\n      this.molecule.deleteAtom(hIndex);\n    });\n  }\n\n  getCoordinates3D() {\n    if (!this.molecule) {\n      console.error(&#x27;Molecule is not initialized&#x27;);\n      return [];\n    }\n    const coordinates3D = [];\n    for (let i = 0; i &lt; this.molecule.getAllAtoms(); i++) {\n      const x = this.molecule.getAtomX(i);\n      const y = this.molecule.getAtomY(i);\n      const z = this.molecule.getAtomZ(i);\n      coordinates3D.push({ x, y, z });\n    }\n    return coordinates3D;\n  }\n\n  getBondTypes() {\n    const bondCount = this.molecule.getAllBonds();\n    const bondTypes = [];\n    for (let i = 0; i &lt; bondCount; i++) {\n      const atom1 = this.molecule.getBondAtom(0, i);\n      const atom2 = this.molecule.getBondAtom(1, i);\n      const bondOrder = this.molecule.getBondOrder(i);\n      let bondType;\n      switch (bondOrder) {\n        case 0:\n          bondType=&#x27;none&#x27;;\n          break;\n        case 1:\n          bondType = &#x27;single&#x27;;\n          break;\n        case 2:\n          bondType = &#x27;double&#x27;;\n          break;\n        case 3:\n          bondType = &#x27;triple&#x27;;\n          break;\n        default:\n          bondType = &#x27;other&#x27;;\n      }\n      bondTypes.push({ atom1, atom2, type: bondType });\n    }\n    return bondTypes;\n  }\n\n  getFormalCharges() {\n    const formalCharges = [];\n    for (let i = 0; i &lt; this.molecule.getAllAtoms(); i++) {\n      const charge = this.molecule.getAtomCharge(i);\n      formalCharges.push(charge);\n    }\n    return formalCharges;\n  }\n\n  // Get the current molecule object\n  getMolecule() {\n    return this.molecule;\n  }\n\n  // Get lone pairs for a specific atom\n  getLonePairs(atomIndex) {\n    return this.lonePairs[atomIndex] || 0;\n  }\n\n  getBondOrder(atom1, atom2) {\n    const bondIndex = this.findBondIndex(atom1, atom2);\n    return bondIndex !== -1 ? this.molecule.getBondOrder(bondIndex) : 0;\n  }\n\n  setBondOrder(atom1, atom2, newOrder) {\n    const bondIndex = this.findBondIndex(atom1, atom2);\n    if (bondIndex !== -1) {\n      this.molecule.setBondOrder(bondIndex, newOrder);\n    }\n  }\n\n  findBondIndex(atom1, atom2) {\n    const bondCount = this.molecule.getAllBonds();\n    for (let i = 0; i &lt; bondCount; i++) {\n      const bondAtom1 = this.molecule.getBondAtom(0, i);\n      const bondAtom2 = this.molecule.getBondAtom(1, i);\n      if ((bondAtom1 === atom1 &amp;&amp; bondAtom2 === atom2) || (bondAtom1 === atom2 &amp;&amp; bondAtom2 === atom1)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  initializeLonePairs() {\n    const atomCount = this.molecule.getAllAtoms();\n    this.lonePairs = {};\n\n    for (let i = 0; i &lt; atomCount; i++) {\n      const atomSymbol = this.molecule.getAtomLabel(i);\n      const formalCharge = this.molecule.getAtomCharge(i);\n      const connectedAtoms = this.molecule.getAllConnAtoms(i);\n      const bondOrders = this.getBondOrdersForAtom(i);\n      const implicitHydrogens = this.molecule.getImplicitHydrogens(i);\n      const explicitHydrogens = this.getExplicitHydrogens(i);\n      \n      // console.log(`Atom ${i} (${atomSymbol}):`);\n      // console.log(`  Connected atoms: ${connectedAtoms}`);\n      // console.log(`  Bond orders: ${bondOrders}`);\n      // console.log(`  Implicit hydrogens: ${implicitHydrogens}`);\n      // console.log(`  Explicit hydrogens: ${explicitHydrogens}`);\n      \n      this.lonePairs[i] = this.calculateLonePairs(\n        i, // Pass the atom index\n        atomSymbol, \n        formalCharge, \n        connectedAtoms, \n        bondOrders, \n        implicitHydrogens + explicitHydrogens\n      );\n      \n      //console.log(`  Calculated lone pairs: ${this.lonePairs[i]}`);\n    } \n  }\n\n  getExplicitHydrogens(atomIndex) {\n    let explicitHydrogens = 0;\n    const connectedAtoms = this.molecule.getAllConnAtoms(atomIndex);\n    for (let i = 0; i &lt; connectedAtoms; i++) {\n      const connectedAtom = this.molecule.getConnAtom(atomIndex, i);\n      if (this.molecule.getAtomLabel(connectedAtom) === &#x27;H&#x27;) {\n        explicitHydrogens++;\n      }\n    }\n    return explicitHydrogens;\n  }\n\n  getBondOrdersForAtom(atomIndex) {\n    const bondOrders = [];\n    const connectedAtoms = this.molecule.getAllConnAtoms(atomIndex);\n    for (let i = 0; i &lt; connectedAtoms; i++) {\n      const connectedAtom = this.molecule.getConnAtom(atomIndex, i);\n      const bondIndex = this.findBondIndex(atomIndex, connectedAtom);\n      let bondOrder = this.molecule.getBondOrder(bondIndex);\n      // Handle aromatic bonds\n      if (bondOrder === 0 &amp;&amp; this.molecule.isAromaticBond(bondIndex)) {\n        bondOrder = 1.5;  // Treat aromatic bonds as 1.5 order\n      }\n      bondOrders.push(bondOrder);\n    }\n    return bondOrders;\n  }\n\n  calculateLonePairs(atomIndex, atomSymbol, formalCharge, connectedAtoms, bondOrders, implicitHydrogens) {\n    if (this.valenceElectrons[atomSymbol] === undefined) {\n      return 0; // Return 0 for unknown atoms\n    }\n\n    const valence = this.valenceElectrons[atomSymbol];\n    let totalBondOrder = bondOrders.reduce((sum, order) =&gt; sum + order, 0) + implicitHydrogens;\n    // Adjust totalBondOrder for non-carbon atoms with implicit hydrogens\n    if (atomSymbol !== &#x27;C&#x27; &amp;&amp; implicitHydrogens &gt; 0) {\n      totalBondOrder = bondOrders.reduce((sum, order) =&gt; sum + order, 0);\n    }\n    // Calculate the number of electrons involved in bonding\n    const bondingElectrons = totalBondOrder;\n    \n    // Calculate the number of non-bonding electrons\n    const nonBondingElectrons = valence - bondingElectrons + formalCharge;\n    \n    // Calculate the number of lone pairs\n    const lonePairs = Math.max(0, Math.floor(nonBondingElectrons / 2));\n    const singleElectrons = nonBondingElectrons % 2;\n\n    this.setSingleElectron(atomIndex, singleElectrons);\n\n    return lonePairs;\n  }\n\n  setSingleElectron(atomIndex, count) {\n    this.singleElectrons[atomIndex] = count;\n  }\n\n  getSingleElectron(atomIndex) {\n    return this.singleElectrons[atomIndex] || 0;\n  }\n\n  getAtomCount() {\n    return this.molecule.getAllAtoms();\n  }\n\n  getFormalCharge(atomIndex) {\n    return this.molecule.getAtomCharge(atomIndex);\n  }\n\n  getAtomIndex(x, y, scale = 1) {\n    const atomCount = this.molecule.getAllAtoms();\n    const tolerance = 0.3 * scale; // Adjust based on rendering scale\n    let closestAtom = -1;\n    let minDistance = Infinity;\n\n    for (let i = 0; i &lt; atomCount; i++) {\n      const dx = (x / scale) - this.molecule.getAtomX(i);\n      const dy = (y / scale) - this.molecule.getAtomY(i);\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      if (distance &lt; minDistance) {\n        minDistance = distance;\n        closestAtom = i;\n      }\n    }\n\n    return minDistance &lt;= tolerance ? closestAtom : -1;\n  }\n}\n"};

        function getFunctionName(content, lineIndex) {
            const lines = content.split('\n');
            for (let i = lineIndex; i >= 0; i--) {
                const match = lines[i].match(/function\s+(\w+)/);
                if (match) return match[1];
            }
            return 'Global Scope';
        }

        function isLineComment(line) {
            return line.trim().startsWith('//') || line.trim().startsWith('/*') || line.trim().endsWith('*/');
        }

        function showVariableFlow() {
            const selectedVar = document.getElementById('variableSelect').value;
            const flowContainer = document.getElementById('flowContainer');
            flowContainer.innerHTML = '';

            if (selectedVar && variables[selectedVar]) {
                variables[selectedVar].forEach(([filename, action]) => {
                    const content = fileContents[filename];
                    const lines = content.split('\n');
                    lines.forEach((line, index) => {
                        if (line.includes(selectedVar) && !isLineComment(line)) {
                            const flowItem = document.createElement('div');
                            flowItem.className = 'flow-item';
                            
                            const filenameP = document.createElement('p');
                            filenameP.className = 'filename';
                            filenameP.textContent = `File: ${filename}`;
                            flowItem.appendChild(filenameP);

                            const functionName = getFunctionName(content, index);
                            const functionP = document.createElement('p');
                            functionP.className = 'function-name';
                            functionP.textContent = `Function: ${functionName}`;
                            flowItem.appendChild(functionP);

                            const actionP = document.createElement('p');
                            actionP.className = 'action';
                            actionP.textContent = `Action: ${action}`;
                            flowItem.appendChild(actionP);

                            const codeP = document.createElement('p');
                            const highlightedLine = line.replace(new RegExp('\\b' + selectedVar + '\\b', 'g'), '<span class="highlight">' + selectedVar + '</span>');
                            codeP.innerHTML = `<span class="line-number">Line ${index + 1}:</span> <code class="code">${highlightedLine}</code>`;
                            flowItem.appendChild(codeP);

                            flowContainer.appendChild(flowItem);
                        }
                    });
                });
            }
        }

        document.getElementById('variableSelect').addEventListener('change', showVariableFlow);
        </script>
    </body>
    </html>
    